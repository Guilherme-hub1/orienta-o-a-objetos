# -*- coding: utf-8 -*-
"""guilhermy-poo_sql-atividades-projeto-ipynh.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/Guilherme-hub1/bdd2b5d3a582a96edb4fcb9a75a85b23/guilhermy-poo_sql-atividades-projeto-ipynh.ipynb
"""

#Guilhermy dos anjos santos
#RGM: 40447731

#Módulo 8
#Orientação a Objetos
numero = '123-4'
titular = "João"
saldo = 120.0
limite = 1000.0

#necessidade de representar mais de uma conta
numero1 = '123-4'
titular1 = "João"
saldo1 = 120.0
limite1 = 1000.0

numero2 = '123-5'
titular2 = "José"
saldo2 = 200.0
limite2 = 1000.0

conta = {"numero": '123-4', "titular": "João", "saldo": 120.0, "limite": 1000.0}

#acessar os dados de uma conta
conta['numero']

#criar uma segunda conta
conta2 = {"numero": '123-5', "titular": "José", "saldo": 200.0, "limite": 1000.0}

#Podemos isolar esse código em uma função responsável por criar uma conta:
def cria_conta():
    conta = {"numero": '123-4', "titular": "João", "saldo": 120.0, "limite": 1000.0}
    return conta

    #o ideal é receber esse valores como parâmetros da função, e por fim retornamos a conta:
def cria_conta(numero, titular, saldo, limite):
    conta = {"numero": numero, "titular": titular, "saldo": saldo, "limite": limite}
    return conta

conta1 = cria_conta('123-4', 'João', 120.0, 1000.0)
conta2 = cria_conta('123-5', 'José', 200.0, 1000.0)

#Funcionalidades
def deposita(conta, valor):
    conta['saldo'] = conta['saldo'] + valor

def deposita(conta, valor):
    conta['saldo'] += valor

def saca(conta, valor):
    conta['saldo'] -= valor

def extrato(conta):
    print("numero: {} \nsaldo: {}".format(conta['numero'], conta['saldo']))
#O extrato imprime as informações da conta utilizando a função print().

#Testar o codigo
conta = cria_conta('123-4', 'João', 120.0, 1000.0)
deposita(conta, 15.0)
extrato(conta)

#numero: '123-4'
#saldo: 135.0

saca(conta, 20.0)
extrato(conta)

#numero: '123-4'
#saldo 115.0

#Módulo 8
#Orientação a Objetos
numero = '123-4'
titular = "João"
saldo = 120.0
limite = 1000.0

#necessidade de representar mais de uma conta
numero1 = '123-4'
titular1 = "João"
saldo1 = 120.0
limite1 = 1000.0

numero2 = '123-5'
titular2 = "José"
saldo2 = 200.0
limite2 = 1000.0

conta = {"numero": '123-4', "titular": "João", "saldo": 120.0, "limite": 1000.0}

#acessar os dados de uma conta
conta['numero']

#criar uma segunda conta
conta2 = {"numero": '123-5', "titular": "José", "saldo": 200.0, "limite": 1000.0}

#Podemos isolar esse código em uma função responsável por criar uma conta:
def cria_conta():
    conta = {"numero": '123-4', "titular": "João", "saldo": 120.0, "limite": 1000.0}
    return conta

    #o ideal é receber esse valores como parâmetros da função, e por fim retornamos a conta:
def cria_conta(numero, titular, saldo, limite):
    conta = {"numero": numero, "titular": titular, "saldo": saldo, "limite": limite}
    return conta

conta1 = cria_conta('123-4', 'João', 120.0, 1000.0)
conta2 = cria_conta('123-5', 'José', 200.0, 1000.0)

#Funcionalidades
def deposita(conta, valor):
    conta['saldo'] = conta['saldo'] + valor

def deposita(conta, valor):
    conta['saldo'] += valor

def saca(conta, valor):
    conta['saldo'] -= valor

def extrato(conta):
    print("numero: {} \nsaldo: {}".format(conta['numero'], conta['saldo']))
#O extrato imprime as informações da conta utilizando a função print().

#Testar o codigo
conta = cria_conta('123-4', 'João', 120.0, 1000.0)
deposita(conta, 15.0)
extrato(conta)

#numero: '123-4'
#saldo: 135.0

saca(conta, 20.0)
extrato(conta)

#numero: '123-4'
#saldo 115.0

#Módulo 9
#encapsulamento

class Conta:

    def __init__(self, numero, titular, saldo, limite=1000.0):
        self.numero = numero   # Número da conta
        self.titular = titular # Nome do titular
        self.saldo = saldo     # Saldo inicial
        self.limite = limite   # Limite da conta

# outros métodos
    def saca(self, valor):
        self.saldo -= valor

# minha_conta = Conta('123-4', 'João', 1000.0, 2000.0)
# minha_conta.saca(500000)

#alterar o saldo diretamente:
# minha_conta = Conta('123-4', 'João', 1000.0)
# minha_conta.saldo = -200

#Para evitar isso seria testar se não estamos sacando um valor maior que o saldo toda vez que formos alterá-lo.

minha_conta = Conta('123-4', 'joão', 1000.0) # Define minha_conta
novo_saldo = -200 # Define novo_saldo

if (novo_saldo < 0):
    print("saldo inválido")
else:
    minha_conta.saldo = novo_saldo

#Módulo 10
#Pycharm
  class Conta:

      def __init__(self, numero, titular, saldo, limite=1000.0):
         # Construtor que inicializa os atributos da conta
          self._numero = numero  # Número da conta (ex: "123-4")
          self._titular = titular # Nome do titular da conta
          self._saldo = saldo # Saldo inicial da conta
          self._limite = limite # Limite de crédito da conta


# Método para depositar um valor na conta
      def deposita(self, valor):
          self._saldo += valor

      def exibe_dados(self):
          print(f"Número: {self._numero}")
          print(f"Titular: {self._titular}")
          print(f"Saldo: {self._saldo}")
          print(f"Limite: {self._limite}")

# Bloco principal para testes — executado apenas se o script for rodado diretamente
  if __name__ == '__main__':
      conta = Conta('123-4', 'João', 1200.0)
      conta.deposita(100.0)
      conta.exibe_dados()

#Módulo 11
#Herança e classe
class Funcionario:

    def __init__(self, nome, cpf, salario):
        self._nome = nome # Nome do funcionário
        self._cpf = cpf # CPF do funcionário
        self._salario = salario # Salário base do funcionário

    def get_bonificacao(self):
      # Calcula a bonificação como 10% do salário
        return self._salario * 0.10

    def __str__(self):
       # Representação em string para imprimir informações básicas
        return f'Funcionario: {self._nome}, CPF: {self._cpf}, Salário: {self._salario}'


# Classe derivada Gerente
class Gerente(Funcionario):

    def __init__(self, nome, cpf, salario, senha, qtd_gerenciaveis):
        super().__init__(nome, cpf, salario) # Inicializa atributos da classe pai
        self._senha = senha  # Senha de acesso do gerente
        self._qtd_gerenciaveis = qtd_gerenciaveis # Quantidade de funcionários gerenciáveis

    def autentica(self, senha):
      # Verifica se a senha fornecida confere com a senha do gerente
        if self._senha == senha:
            print("Acesso permitido")
            return True
        else:
            print("Acesso negado")
            return False

    def get_bonificacao(self):
      # Bonificação do gerente = bonificação padrão + bônus fixo de 1000
        return super().get_bonificacao() + 1000.0

    def __str__(self):
       # Representação em string incluindo informações específicas do gerente
        return f'Gerente: {self._nome}, CPF: {self._cpf}, Salário: {self._salario}, Gerencia: {self._qtd_gerenciaveis}'


# Classe genérica para testes de __str__ e __repr__
class MinhaClasse:
    def __str__(self):
        # Mostra nome da classe e endereço de memória da instância
        return f'<Instância de {self.__class__.__name__}; endereço: {hex(id(self))}>'


# Testes
if __name__ == '__main__':
    funcionario = Funcionario('João', '111111111-11', 2000.0)
    print(funcionario) # Imprime dados via __str__
    print("Bonificação do funcionário:", funcionario.get_bonificacao())
    print(vars(funcionario))  # Mostra dicionário interno de atributos


    gerente = Gerente('José', '222222222-22', 5000.0, '1234', 3)
    print(gerente)  # Imprime dados do gerente
    print("Bonificação do gerente:", gerente.get_bonificacao())
    print("Autenticação com senha correta:", gerente.autentica('1234'))
    print("Autenticação com senha incorreta:", gerente.autentica('0000'))
    print(vars(gerente))   # Mostra atributos internos

    mc = MinhaClasse()
    # Testando MinhaClasse
    print(mc)
    print(repr(mc))  # Usa __repr__ padrão, mostra detalhe de classe

#Módulo 12
#Herança multipla e interfaces

# Classe base
class Funcionario:
    def __init__(self, nome, cpf, salario):
        self._nome = nome
        self._cpf = cpf
        self._salario = salario


# MixIn de autenticação
class AutenticavelMixIn:
    def __init__(self, senha):
        self._senha = senha  # Armazena a senha para autenticação

    def autentica(self, senha):
        if self._senha == senha:
            print(f"Acesso permitido para {self.__class__.__name__}")
            return True
        else:
            print(f"Acesso negado para {self.__class__.__name__}")
            return False


# MixIn de atendimento
class AtendimentoMixIn:
    def cadastra_atendimento(self):
      # Simula o cadastro de um atendimento
        print(f"{self.__class__.__name__}: Atendimento cadastrado com sucesso.")

    def atende_cliente(self):
      # Simula o atendimento de um cliente
        print(f"{self.__class__.__name__}: Cliente atendido com sucesso.")


# MixIn de hora extra
class HoraExtraMixIn:
    def calcula_hora_extra(self, horas):
        valor = horas * 50  # Suponha R$50 por hora
        print(f"{self.__class__.__name__}: Hora extra calculada: R${valor:.2f}")
        return valor


# Classes especializadas
class Gerente(Funcionario, AutenticavelMixIn, HoraExtraMixIn):
    def __init__(self, nome, cpf, salario, senha):
      # Inicializa as classes base
        Funcionario.__init__(self, nome, cpf, salario)
        AutenticavelMixIn.__init__(self, senha)


# Classe Diretor: herda de Funcionario e AutenticavelMixIn
class Diretor(Funcionario, AutenticavelMixIn):
    def __init__(self, nome, cpf, salario, senha):
        Funcionario.__init__(self, nome, cpf, salario)
        AutenticavelMixIn.__init__(self, senha)

# Classe Cliente: herda apenas de AutenticavelMixIn
class Cliente(AutenticavelMixIn):
    def __init__(self, nome, cpf, senha):
        self._nome = nome
        self._cpf = cpf
        super().__init__(senha)

# Classe Escriturario: herda de Funcionario e AtendimentoMixIn
class Escriturario(Funcionario, AtendimentoMixIn):
    def __init__(self, nome, cpf, salario):
        super().__init__(nome, cpf, salario)


# Sistema de login
class SistemaInterno:
    def login(self, obj, senha):
        if hasattr(obj, 'autentica'):
            return obj.autentica(senha)
        else:
            print(f'{obj.__class__.__name__} não é autenticável')
            return False


# Testes
if __name__ == '__main__':
    gerente = Gerente('José', '222222222-22', 5000.0, '1234')
    diretor = Diretor('João', '111111111-11', 7000.0, 'abcd')
    cliente = Cliente('Maria', '333333333-33', '9999')
    escriturario = Escriturario('Ana', '444444444-44', 2500.0)

    sistema = SistemaInterno()
 # Testa o login de diferentes perfis
    sistema.login(gerente, '1234')     # Acesso permitido
    sistema.login(diretor, 'errada')   # Acesso negado
    sistema.login(cliente, '9999')     # Acesso permitido
    sistema.login(escriturario, '123') # Não é autenticável

 # Testa funcionalidades específicas
    gerente.calcula_hora_extra(4)      # Calcula hora extra
    escriturario.atende_cliente()      # Atende cliente
    escriturario.cadastra_atendimento()

#Módulo 13
#excecoes-e-erros.md

class Conta:
    def __init__(self, numero, titular, saldo=0.0, limite=1000.0):
      # Inicializa os atributos da conta
        self.numero = numero
        self.titular = titular
        self.saldo = saldo
        self.limite = limite

    def deposita(self, valor):
      # Adiciona um valor ao saldo da conta
        self.saldo += valor

    def saca(self, valor):
     # Realiza um saque, verificando se está dentro do saldo + limite
        if valor > self.saldo + self.limite:
            print("Não posso sacar fora do limite")
            return False # Indica que o saque não foi realizado
        else:
            self.saldo -= valor
            return True # Saque realizado com sucesso
#teste

# Criação de uma conta com número e titular (saldo e limite usam os valores padrão)
conta = Conta("123-4", "João")
conta.deposita(100.0) # Depósito de R$100,00 na conta
conta.limite = 100.0 # Redefine o limite da conta para R$100,00


# Tenta sacar R$3000,00 (excede saldo + limite)
if not conta.saca(3000.0):
    print("não saquei")  # Se o saque não foi realizado, imprime mensagem

#módulo 14
#-collections.md

from collections import UserDict

# Classe que herda diretamente de UserDict, sem nenhuma modificação adicional
class MeuDicionario(UserDict):
    pass

# Classe Pins que herda de UserDict e modifica o comportamento de alguns métodos
class Pins(UserDict):

    def __contains__(self, key):
        # Verifica se a chave (convertida para string) está presente
        return str(key) in self.keys()

    def __setitem__(self, key, value):
        # Sempre armazena a chave como string
        self.data[str(key)] = value


# Bloco principal de execução
if __name__ == '__main__':
  # Cria uma instância de Pins com uma chave inicial 'one'
    pins = Pins(one=1)
    print("Dicionário inicial:", pins)

    pins[3] = 1  # chave será convertida para '3'
    print("Após adicionar pins[3]:", pins)


 # Tenta usar uma lista como chave, o que causará erro
    # porque listas não são hashable (não podem ser usadas como chave de dicionário)
    lista = [1, 2, 3]
    try:
        pins[lista] = 2  # vai dar erro: listas não podem ser convertidas em strings para uso como chave
    except TypeError as e:
        print("Erro ao usar lista como chave:", e)

 # Mostra o dicionário final após as operações
    print("Dicionário final:", pins)